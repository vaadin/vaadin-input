<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="vaadin-text-field-mixin.html">
<link rel="import" href="../../vaadin-control-state-mixin/vaadin-control-state-mixin.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">

<dom-module id="vaadin-text-area">
  <template>
    <style include="vaadin-text-field-shared-styles">
      .vaadin-text-area-container {
        flex: auto;
        max-height: inherit; /* MSIE 11 */
        min-height: inherit; /* MSIE 11 */
      }

      /* The label, helper text and the error message should neither grow nor shrink. */
      [part="label"],
      [part="helper-text"],
      [part="error-message"] {
        flex: none;
      }

      [part="input-field"] {
        overflow: hidden;
        align-items: flex-start;
      }

      [part="clear-button"] {
        align-self: center;
      }

      [part="value"] {
        resize: none;
      }

      .textarea-wrapper {
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        width: 100%;
        display: flex;
        flex: auto;
        box-sizing: border-box;
        height: 100%;
      }

      [part="value"],
      .textarea-wrapper ::slotted(textarea) {
        /* reset ua stylesheet */
        -webkit-appearance: none;
        -moz-appearance: none;
        outline: none;
        margin: 0;
        padding: 0;
        border: 0;
        border-radius: 0;
        min-width: 0;
        font: inherit;
        font-size: 1em;
        line-height: normal;
        background-color: transparent;
        box-shadow: none;

        flex: auto;
        overflow: hidden;
        width: 100%;
        height: 100%;
        color: var(--lumo-body-text-color);
      }

      @supports (display: grid) {
        [part="input-field"] {
          overflow: auto;
          -webkit-overflow-scrolling: touch;
        }

        .textarea-wrapper {
          overflow: initial;
          width: 100%;
          display: grid;
          flex-grow: 1;
          align-self: stretch;
          box-sizing: content-box;
          height: initial;
        }

        .textarea-wrapper::after {
          content: attr(data-replicated-value) ' ';
          white-space: pre-wrap;
          visibility: hidden;
        }

        [part='value'],
        .textarea-wrapper ::slotted(textarea) {
          resize: none;
          overflow: hidden;
        }

        [part='value'],
        .textarea-wrapper ::slotted(textarea),
        .textarea-wrapper::after {
          grid-area: 1 / 1 / 2 / 2;
          box-sizing: border-box;
          padding: 0 0.25em;
          overflow-wrap: break-word;
          word-wrap: break-word;
          word-break: break-word;
        }
      }

      @keyframes vaadin-text-area-appear {
        to {
          opacity: 1;
        }
      }

      :host {
        animation: 1ms vaadin-text-area-appear;
      }
    </style>

    <div class="vaadin-text-area-container">

      <label part="label" on-click="focus" id="[[_labelId]]">[[label]]</label>

      <div part="input-field" id="[[_inputId]]">

        <slot name="prefix"></slot>

        <div class="textarea-wrapper">
          <slot name="textarea">
            <textarea part="value"></textarea>
          </slot>
        </div>

        <div part="clear-button" id="clearButton" role="button" aria-label$="[[i18n.clear]]"></div>
        <slot name="suffix"></slot>

      </div>

      <div part="helper-text" on-click="focus" id="[[_helperTextId]]">
        <slot name="helper">[[helperText]]</slot>
      </div>

      <div part="error-message"
        id="[[_errorId]]"
        aria-live="assertive"
        aria-hidden$="[[_getErrorMessageAriaHidden(invalid, errorMessage, _errorId)]]"
      >[[errorMessage]]</div>

    </div>

  </template>

  <script>
    (function() {
      /**
       * `<vaadin-text-area>` is a Web Component for text area control in forms.
       *
       * ```html
       * <vaadin-text-area label="Add description">
       * </vaadin-text-area>
       * ```
       *
       * ### Prefixes and suffixes
       *
       * These are child elements of a `<vaadin-text-area>` that are displayed
       * inline with the input, before or after.
       * In order for an element to be considered as a prefix, it must have the slot
       * attribute set to `prefix` (and similarly for `suffix`).
       *
       * ```html
       * <vaadin-text-area label="Add description">
       *   <div slot="prefix">Details:</div>
       *   <div slot="suffix">The end!</div>
       * </vaadin-text-area>
       * ```
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ----------------|----------------
       * `label` | The label element
       * `input-field` | The element that wraps prefix, value and suffix
       * `value` | The text value element inside the `input-field` element
       * `error-message` | The error message element
       *
       * The following state attributes are available for styling:
       *
       * Attribute    | Description | Part name
       * -------------|-------------|------------
       * `disabled` | Set to a disabled text field | :host
       * `has-value` | Set when the element has a value | :host
       * `has-label` | Set when the element has a label | :host
       * `has-helper` | Set when the element has helper text | :host
       * `has-error-message` | Set when the element has an error message | :host
       * `invalid` | Set when the element is invalid | :host
       * `focused` | Set when the element is focused | :host
       * `focus-ring` | Set when the element is keyboard focused | :host
       * `readonly` | Set to a readonly text field | :host
       *
       * See [ThemableMixin â€“ how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * @memberof Vaadin
       * @mixes Vaadin.TextFieldMixin
       * @mixes Vaadin.ControlStateMixin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */
      class TextAreaElement extends
        Vaadin.ElementMixin(
          Vaadin.TextFieldMixin(
            Vaadin.ControlStateMixin(
              Vaadin.ThemableMixin(Polymer.Element)))) {
        static get is() {
          return 'vaadin-text-area';
        }

        static get version() {
          return '2.8.4';
        }

        static get observers() {
          return [
            '_textAreaValueChanged(value)'
          ];
        }

        /** @protected */
        ready() {
          super.ready();
          this._updateHeight();
          this.addEventListener('animationend', this._onAnimationEnd);
          this.__safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        }

        /** @private */
        _onAnimationEnd(e) {
          if (e.animationName.indexOf('vaadin-text-area-appear') === 0) {
            this._updateHeight();
          }
        }

        /**
         * @return {string}
         * @protected
         */
        get _slottedTagName() {
          return 'textarea';
        }

        /** @private */
        _textAreaValueChanged(value) {
          this._updateHeight();
        }

        /** @private */
        _updateHeight() {
          const isIE = window.document.documentMode;
          if (!isIE) {
            /* https://css-tricks.com/the-cleanest-trick-for-autogrowing-textareas/ */
            this._textAreaWrapper = this._textAreaWrapper || this.shadowRoot.querySelector('.textarea-wrapper');
            this._textAreaWrapper.dataset.replicatedValue = this.inputElement.value;
            // getComputedStyle is expensive, maybe we can use ResizeObserver in the future
            this._dispatchIronResizeEventIfNeeded('InputHeight', getComputedStyle(this._textAreaWrapper).height);

            return;
          }

          const inputField = this.root.querySelector('[part=input-field]');
          const scrollTop = inputField.scrollTop;
          const input = this.inputElement;

          const inputWidth = getComputedStyle(input).width;

          const valueLength = this.value ? this.value.length : 0;
          const y = window.pageYOffset || document.documentElement.scrollTop;
          // Only clear the height when the content shortens to minimize scrollbar flickering.
          if (this._oldValueLength >= valueLength) {
            // Fix the input element width so its scroll height isn't affected by host's disappearing scrollbars
            input.style.maxWidth = inputWidth;
            input.style.height = 'auto';
            input.style.padding = '0';
            // Avoid a jumpy Safari rendering issue
            if (this.__safari) {
              inputField.style.display = 'block';
            }
          }
          this._oldValueLength = valueLength;

          const inputHeight = input.scrollHeight;
          if (inputHeight > input.clientHeight) {
            input.style.height = inputHeight + 'px';
          }

          // Restore
          input.style.removeProperty('max-width');
          input.style.removeProperty('padding');
          inputField.style.removeProperty('display');
          inputField.scrollTop = scrollTop;
          document.documentElement.scrollTop = y;

          this._dispatchIronResizeEventIfNeeded('InputHeight', inputHeight);
        }

        /**
         * Fired when the text-area height changes.
         *
         * @event iron-resize
         */
      }

      customElements.define(TextAreaElement.is, TextAreaElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin = window.Vaadin || {};
      Vaadin.TextAreaElement = TextAreaElement;
    })();
  </script>
</dom-module>
