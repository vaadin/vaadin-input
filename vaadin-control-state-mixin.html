<script>

  // Polymer.IronControlState is not a proper 2.0 class, also, its tabindex
  // implementation fails in the shadow dom, so we have this for vaadin elements.
  window.VaadinControlStateMixin = subclass => class extends subclass {
    static get config() {
      return {
        properties: {
          /**
           * If true, the element currently has focus.
           */
          focused: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true,
            observer: '_focusedChanged',
            reflectToAttribute: true
          },

          /**
           * If true, the user cannot interact with this element.
           */
          disabled: {
            type: Boolean,
            observer: '_disabledChanged',
            reflectToAttribute: true
          },

          /**
           * Internal property needed to listen to `tabindex` attribute changes.
           *
           * For changing the tabindex of this component use the native `tabIndex` propety.
           * @private
           */
          tabindex: {
            type: Number,
            observer: '_tabindexChanged'
          }
        }
      };
    }

    ready() {
      super.ready();

      // Make FF take the focus (#9)
      if (this.autofocus) {
        this.focus();
      }

      this.addEventListener('focus', this._focus.bind(this));

      Polymer.RenderStatus.afterNextRender(this, () => {
        this._getFocusElement().addEventListener('focus', this._onElemFocus.bind(this));
        this._getFocusElement().addEventListener('blur', this._onElemBlur.bind(this));
        this._getFocusElement().addEventListener('keydown', this._onElemKeydown.bind(this));
      });
    }

    _getFocusElement() {
      window.console.warn(`Please implement _getFocusElement() in <${this.localName}>`);
      return this;
    }

    _onElemFocus() {
      this._setFocused(true);
    }

    _focus() {
      this._getFocusElement().focus();
    }

    _onElemBlur() {
      this._setFocused(false);
      this.invalid = this._isInvalid();
    }

    blur() {
      this._getFocusElement().blur();
    }

    _onElemKeydown(e) {
      // on shift-tab
      if (e.shiftKey && e.keyCode === 9) {
        this.focus();
      }
    }

    _disabledChanged(disabled) {
      this._getFocusElement().disabled = disabled;
      if (disabled) {
        this.blur();
        this._setTabindex(undefined);
      } else {
        this.tabIndex = this._getFocusElement().tabIndex;
      }
    }

    _tabindexChanged(tabindex) {
      if (!this._tabindexLocked) {
        this._getFocusElement().tabIndex = tabindex;
        if (this.disabled) {
          this._setTabindex(undefined);
        }
        if (window.ShadyDOM) {
          this._setTabindex(-1);
        }
      }
    }

    _setTabindex(tabindex) {
      this._tabindexLocked = true;
      if (tabindex === undefined) {
        this.removeAttribute('tabindex');
      } else {
        this.setAttribute('tabindex', tabindex);
      }
      delete this._tabindexLocked;
    }

    _focusedChanged() {
      // Needed for Edge, until they have support for CSS Custom Properties
      // (already shipping in Edge Preview)
      this.updateStyles();
    }
  };
</script>
